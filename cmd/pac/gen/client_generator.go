package gen

import (
	"fmt"
	"io"
	"strings"
)

// ClientGenerator generates TypeScript client code from parsed lexicon definitions
type ClientGenerator struct {
	parser *Parser
}

// NewClientGenerator creates a new client generator
func NewClientGenerator() *ClientGenerator {
	return &ClientGenerator{
		parser: NewParser(),
	}
}

// GenerateClient generates TypeScript client code from a lexicon reader
func (g *ClientGenerator) GenerateClient(inputReader io.Reader) ([]byte, error) {
	// Parse the lexicon document
	doc, err := g.parser.ParseLexicon(inputReader)
	if err != nil {
		return nil, fmt.Errorf("failed to parse lexicon: %w", err)
	}

	// Parse all definitions
	parsedDefs, err := g.parser.ParseDefinitions(doc)
	if err != nil {
		return nil, fmt.Errorf("failed to parse definitions: %w", err)
	}

	// Find record definitions
	var recordDef *RecordDefinition
	for _, def := range parsedDefs {
		if rd, ok := def.(RecordDefinition); ok {
			recordDef = &rd
			break
		}
	}

	if recordDef == nil {
		return nil, fmt.Errorf("no record definition found in lexicon")
	}

	// Generate TypeScript client code
	var output strings.Builder

	// Generate entity name from lexicon ID (last part of the ID)
	entityName := g.getEntityName(doc.ID)
	entityNamePascal := g.toPascalCase(entityName)
	entityNamePlural := g.toPascalCase(g.pluralize(entityName))

	// Add header comment
	output.WriteString(fmt.Sprintf("// Generated TypeScript client from atproto lexicon: %s\n", doc.ID))
	if doc.Description != "" {
		output.WriteString(fmt.Sprintf("// %s\n", doc.Description))
	}
	output.WriteString("// Generated by pac clientgen\n\n")

	// Add imports
	output.WriteString("import type { ComAtprotoRepoCreateRecord, ComAtprotoRepoGetRecord, ComAtprotoRepoListRecords } from '@atproto/api';\n")
	output.WriteString("import { HabitatClient, getUserDid, getDefaultAgent } from '../sdk/atproto';\n")
	output.WriteString(fmt.Sprintf("import type { PutRecordResponse, GetRecordResponse, ListRecordsResponse } from '../sdk/atproto';\n"))

	// Import the generated types
	typeNamePascal := g.toPascalCase(entityName)
	output.WriteString(fmt.Sprintf("import type { %s } from '../types/%s_types';\n\n", typeNamePascal, entityName))

	// Generate public CRUD operations
	g.generateCreateRecordFunction(&output, entityNamePascal, recordDef)
	output.WriteString("\n")
	g.generateListRecordsFunction(&output, entityNamePlural, recordDef)
	output.WriteString("\n")
	g.generateGetRecordFunction(&output, entityNamePascal, recordDef)
	output.WriteString("\n\n")

	// Add comment for private operations
	output.WriteString("// Convenience functions for private record operations\n")

	// Generate private CRUD operations
	g.generatePutPrivateRecordFunction(&output, entityNamePascal, recordDef)
	output.WriteString("\n")
	g.generateGetPrivateRecordFunction(&output, entityNamePascal, recordDef)
	output.WriteString("\n")
	g.generateListPrivateRecordsFunction(&output, entityNamePlural, recordDef)

	return []byte(output.String()), nil
}

// generateCreateRecordFunction generates the createRecord function
func (g *ClientGenerator) generateCreateRecordFunction(output *strings.Builder, entityName string, record *RecordDefinition) {
	output.WriteString(fmt.Sprintf("export const create%sRecord = async (record: %s): Promise<ComAtprotoRepoCreateRecord.Response['data']> => {\n", entityName, entityName))
	output.WriteString("    const client = new HabitatClient(getUserDid(), getDefaultAgent());\n")
	output.WriteString(fmt.Sprintf("    const response = await client.createRecord<%s>({\n", entityName))
	output.WriteString(fmt.Sprintf("        collection: '%s',\n", record.Key))
	output.WriteString("        record,\n")
	output.WriteString("    });\n")
	output.WriteString("    return response.data;\n")
	output.WriteString("};\n")
}

// generateListRecordsFunction generates the listRecords function
func (g *ClientGenerator) generateListRecordsFunction(output *strings.Builder, entityNamePlural string, record *RecordDefinition) {
	entityName := g.singularize(entityNamePlural)
	output.WriteString(fmt.Sprintf("export const list%s = async (): Promise<ComAtprotoRepoListRecords.Response['data'] & { records: Array<{ uri: string; cid: string; value: %s }> }> => {\n", entityNamePlural, entityName))
	output.WriteString("    const client = new HabitatClient(getUserDid(), getDefaultAgent());\n")
	output.WriteString(fmt.Sprintf("    const response = await client.listRecords<%s>({\n", entityName))
	output.WriteString(fmt.Sprintf("        collection: '%s',\n", record.Key))
	output.WriteString("    });\n")
	output.WriteString("    return response.data;\n")
	output.WriteString("};\n")
}

// generateGetRecordFunction generates the getRecord function
func (g *ClientGenerator) generateGetRecordFunction(output *strings.Builder, entityName string, record *RecordDefinition) {
	output.WriteString(fmt.Sprintf("export const get%sRecord = async (rkey: string): Promise<ComAtprotoRepoGetRecord.Response['data'] & { value: %s }> => {\n", entityName, entityName))
	output.WriteString("    const client = new HabitatClient(getUserDid(), getDefaultAgent());\n")
	output.WriteString(fmt.Sprintf("    const response = await client.getRecord<%s>({\n", entityName))
	output.WriteString(fmt.Sprintf("        collection: '%s',\n", record.Key))
	output.WriteString("        rkey,\n")
	output.WriteString("    });\n")
	output.WriteString("    return response.data;\n")
	output.WriteString("};\n")
}

// generatePutPrivateRecordFunction generates the putPrivateRecord function
func (g *ClientGenerator) generatePutPrivateRecordFunction(output *strings.Builder, entityName string, record *RecordDefinition) {
	output.WriteString(fmt.Sprintf("export const putPrivate%sRecord = async (record: %s, rkey?: string): Promise<PutRecordResponse> => {\n", entityName, entityName))
	output.WriteString("    const client = new HabitatClient(getUserDid(), getDefaultAgent());\n")
	output.WriteString(fmt.Sprintf("    const response = await client.putPrivateRecord<%s>({\n", entityName))
	output.WriteString(fmt.Sprintf("        collection: '%s',\n", record.Key))
	output.WriteString("        rkey,\n")
	output.WriteString("        record,\n")
	output.WriteString("    });\n")
	output.WriteString("    return response;\n")
	output.WriteString("};\n")
}

// generateGetPrivateRecordFunction generates the getPrivateRecord function
func (g *ClientGenerator) generateGetPrivateRecordFunction(output *strings.Builder, entityName string, record *RecordDefinition) {
	output.WriteString(fmt.Sprintf("export const getPrivate%sRecord = async (rkey: string): Promise<GetRecordResponse<%s>> => {\n", entityName, entityName))
	output.WriteString("    const client = new HabitatClient(getUserDid(), getDefaultAgent());\n")
	output.WriteString(fmt.Sprintf("    const response = await client.getPrivateRecord<%s>({\n", entityName))
	output.WriteString(fmt.Sprintf("        collection: '%s',\n", record.Key))
	output.WriteString("        rkey,\n")
	output.WriteString("    });\n")
	output.WriteString("    return response;\n")
	output.WriteString("};\n")
}

// generateListPrivateRecordsFunction generates the listPrivateRecords function
func (g *ClientGenerator) generateListPrivateRecordsFunction(output *strings.Builder, entityNamePlural string, record *RecordDefinition) {
	// Extract entity name from plural form (simple approach - remove 's' or 'es')
	entityName := g.singularize(entityNamePlural)
	output.WriteString(fmt.Sprintf("export const listPrivate%s = async (): Promise<ListRecordsResponse<%s>> => {\n", entityNamePlural, entityName))
	output.WriteString("    const client = new HabitatClient(getUserDid(), getDefaultAgent());\n")
	output.WriteString(fmt.Sprintf("    const response = await client.listPrivateRecords<%s>({\n", entityName))
	output.WriteString(fmt.Sprintf("        collection: '%s',\n", record.Key))
	output.WriteString("    });\n")
	output.WriteString("    return response;\n")
	output.WriteString("};\n")
}

// extractRecordParams extracts function parameters from record schema
func (g *ClientGenerator) extractRecordParams(record *RecordDefinition) string {
	if record.Record == nil {
		return ""
	}

	recordMap, ok := record.Record.(map[string]interface{})
	if !ok {
		return ""
	}

	properties, ok := recordMap["properties"].(map[string]interface{})
	if !ok {
		return ""
	}

	// Get required fields
	required := make(map[string]bool)
	if requiredSlice, ok := recordMap["required"].([]interface{}); ok {
		for _, req := range requiredSlice {
			if reqStr, ok := req.(string); ok {
				required[reqStr] = true
			}
		}
	}

	// Separate required and optional parameters
	var requiredParams []string
	var optionalParams []string

	for propName, propDef := range properties {
		propType := g.getTypeScriptTypeForParam(propDef)
		if required[propName] {
			requiredParams = append(requiredParams, fmt.Sprintf("%s: %s", propName, propType))
		} else {
			optionalParams = append(optionalParams, fmt.Sprintf("%s?: %s", propName, propType))
		}
	}

	// Combine required params first, then optional params
	allParams := append(requiredParams, optionalParams...)
	return strings.Join(allParams, ", ")
}

// writeRecordFields writes the record fields to the output
func (g *ClientGenerator) writeRecordFields(output *strings.Builder, record *RecordDefinition, indent string) {
	if record.Record == nil {
		return
	}

	recordMap, ok := record.Record.(map[string]interface{})
	if !ok {
		return
	}

	properties, ok := recordMap["properties"].(map[string]interface{})
	if !ok {
		return
	}

	for propName := range properties {
		output.WriteString(fmt.Sprintf("%s%s,\n", indent, propName))
	}
}

// getTypeScriptTypeForParam converts a schema definition to a TypeScript type for function parameters
func (g *ClientGenerator) getTypeScriptTypeForParam(schema interface{}) string {
	if schema == nil {
		return "any"
	}

	schemaMap, ok := schema.(map[string]interface{})
	if !ok {
		return "any"
	}

	schemaType, ok := schemaMap["type"].(string)
	if !ok {
		return "any"
	}

	switch schemaType {
	case "string":
		return "string"
	case "integer", "number":
		return "number"
	case "boolean":
		return "boolean"
	case "array":
		if items, ok := schemaMap["items"]; ok {
			itemType := g.getTypeScriptTypeForParam(items)
			return itemType + "[]"
		}
		return "any[]"
	case "object":
		return "Record<string, any>"
	default:
		return "any"
	}
}

// getEntityName extracts the entity name from the lexicon ID
func (g *ClientGenerator) getEntityName(lexiconID string) string {
	parts := strings.Split(lexiconID, ".")
	if len(parts) > 0 {
		return parts[len(parts)-1]
	}
	return "entity"
}

// pluralize adds 's' to the end of a word (simple pluralization)
func (g *ClientGenerator) pluralize(word string) string {
	// Simple pluralization - can be enhanced later
	if strings.HasSuffix(word, "s") || strings.HasSuffix(word, "x") ||
		strings.HasSuffix(word, "z") || strings.HasSuffix(word, "ch") ||
		strings.HasSuffix(word, "sh") {
		return word + "es"
	}
	if strings.HasSuffix(word, "y") && len(word) > 1 {
		// Check if the letter before 'y' is a consonant
		beforeY := word[len(word)-2]
		if !g.isVowel(beforeY) {
			return word[:len(word)-1] + "ies"
		}
	}
	return word + "s"
}

// isVowel checks if a character is a vowel
func (g *ClientGenerator) isVowel(c byte) bool {
	return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||
		c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'
}

// toPascalCase converts a string to PascalCase (reusing from generator.go logic)
func (g *ClientGenerator) toPascalCase(s string) string {
	if s == "" {
		return ""
	}

	// Handle special cases
	if s == "main" {
		return "Main"
	}

	// First, split on common delimiters
	parts := strings.FieldsFunc(s, func(r rune) bool {
		return r == '_' || r == '-' || r == '.' || r == '/'
	})

	var result strings.Builder
	for _, part := range parts {
		if part != "" {
			// Capitalize each word
			result.WriteString(strings.ToUpper(part[:1]) + strings.ToLower(part[1:]))
		}
	}

	return result.String()
}

// singularize converts plural to singular (simple approach, opposite of pluralize)
func (g *ClientGenerator) singularize(word string) string {
	if strings.HasSuffix(word, "ies") && len(word) > 3 {
		return word[:len(word)-3] + "y"
	}
	if strings.HasSuffix(word, "es") && len(word) > 2 {
		base := word[:len(word)-2]
		if strings.HasSuffix(base, "s") || strings.HasSuffix(base, "x") ||
			strings.HasSuffix(base, "z") || strings.HasSuffix(base, "ch") ||
			strings.HasSuffix(base, "sh") {
			return base
		}
	}
	if strings.HasSuffix(word, "s") && len(word) > 1 {
		return word[:len(word)-1]
	}
	return word
}
