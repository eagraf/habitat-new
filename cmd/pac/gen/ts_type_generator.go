package gen

import (
	"fmt"
	"io"
	"strings"
)

// TypeScriptGenerator generates TypeScript types from parsed lexicon definitions
type TypeScriptGenerator struct {
	parser *Parser
}

// NewTypeScriptGenerator creates a new TypeScript generator
func NewTypeScriptGenerator() *TypeScriptGenerator {
	return &TypeScriptGenerator{
		parser: NewParser(),
	}
}

// GenerateTypes generates TypeScript types from a lexicon reader
func (g *TypeScriptGenerator) GenerateTypes(inputReader io.Reader) ([]byte, error) {
	// Parse the lexicon document
	doc, err := g.parser.ParseLexicon(inputReader)
	if err != nil {
		return nil, fmt.Errorf("failed to parse lexicon: %w", err)
	}

	// Parse all definitions
	parsedDefs, err := g.parser.ParseDefinitions(doc)
	if err != nil {
		return nil, fmt.Errorf("failed to parse definitions: %w", err)
	}

	// Generate TypeScript content
	var output strings.Builder

	// Add header comment
	output.WriteString(fmt.Sprintf("// Generated TypeScript types from atproto lexicon: %s\n", doc.ID))
	if doc.Description != "" {
		output.WriteString(fmt.Sprintf("// %s\n", doc.Description))
	}
	output.WriteString("// Generated by pac typegen\n\n")

	// Generate types for each definition
	for name, def := range parsedDefs {
		// If this is the main definition, use the last section of the lexicon ID as the type name
		typeName := name
		if name == "main" {
			typeName = g.getLastSectionOfID(doc.ID)
		}

		if err := g.generateDefinitionType(&output, typeName, def); err != nil {
			return nil, fmt.Errorf("failed to generate type for definition %s: %w", name, err)
		}
		output.WriteString("\n")
	}

	return []byte(output.String()), nil
}

// generateDefinitionType generates TypeScript for a single definition
func (g *TypeScriptGenerator) generateDefinitionType(output *strings.Builder, name string, def interface{}) error {
	switch d := def.(type) {
	case RecordDefinition:
		return g.generateRecordType(output, name, d)
	case QueryDefinition:
		return g.generateQueryType(output, name, d)
	case ProcedureDefinition:
		return g.generateProcedureType(output, name, d)
	case SubscriptionDefinition:
		return g.generateSubscriptionType(output, name, d)
	case SchemaField:
		return g.generateSchemaFieldType(output, name, d)
	default:
		return fmt.Errorf("unsupported definition type: %T", def)
	}
}

// generateRecordType generates TypeScript interface for a record
func (g *TypeScriptGenerator) generateRecordType(output *strings.Builder, name string, record RecordDefinition) error {
	// Add description comment if available
	if record.Description != "" {
		output.WriteString(fmt.Sprintf("/**\n * %s\n */\n", record.Description))
	}

	// Generate interface name
	interfaceName := g.toPascalCase(name)
	output.WriteString(fmt.Sprintf("export interface %s {\n", interfaceName))

	// Add $type field for atproto records
	output.WriteString("  /**\n   * The type identifier for this record\n   */\n")
	output.WriteString(fmt.Sprintf("  $type: '%s';\n\n", record.Key))

	// Generate properties from the record schema
	if record.Record != nil {
		if err := g.generateObjectProperties(output, record.Record, "  "); err != nil {
			return err
		}
	}

	output.WriteString("}\n")
	return nil
}

// generateQueryType generates TypeScript types for a query
func (g *TypeScriptGenerator) generateQueryType(output *strings.Builder, name string, query QueryDefinition) error {
	// Add description comment
	if query.Description != "" {
		output.WriteString(fmt.Sprintf("/**\n * %s\n */\n", query.Description))
	}

	// Generate parameters interface if they exist
	if query.Parameters != nil {
		paramsName := g.toPascalCase(name) + "Params"
		output.WriteString(fmt.Sprintf("export interface %s {\n", paramsName))
		if err := g.generateObjectProperties(output, query.Parameters, "  "); err != nil {
			return err
		}
		output.WriteString("}\n\n")
	}

	// Generate output interface if it exists
	if query.Output != nil && query.Output.Schema != nil {
		outputName := g.toPascalCase(name) + "Output"
		output.WriteString(fmt.Sprintf("export interface %s {\n", outputName))
		if err := g.generateObjectProperties(output, query.Output.Schema, "  "); err != nil {
			return err
		}
		output.WriteString("}\n\n")
	}

	// Generate error types if they exist
	if len(query.Errors) > 0 {
		g.generateErrorTypes(output, name, query.Errors)
	}

	return nil
}

// generateProcedureType generates TypeScript types for a procedure
func (g *TypeScriptGenerator) generateProcedureType(output *strings.Builder, name string, proc ProcedureDefinition) error {
	// Similar to query but with input as well
	if proc.Description != "" {
		output.WriteString(fmt.Sprintf("/**\n * %s\n */\n", proc.Description))
	}

	// Generate parameters interface
	if proc.Parameters != nil {
		paramsName := g.toPascalCase(name) + "Params"
		output.WriteString(fmt.Sprintf("export interface %s {\n", paramsName))
		if err := g.generateObjectProperties(output, proc.Parameters, "  "); err != nil {
			return err
		}
		output.WriteString("}\n\n")
	}

	// Generate input interface
	if proc.Input != nil && proc.Input.Schema != nil {
		inputName := g.toPascalCase(name) + "Input"
		output.WriteString(fmt.Sprintf("export interface %s {\n", inputName))
		if err := g.generateObjectProperties(output, proc.Input.Schema, "  "); err != nil {
			return err
		}
		output.WriteString("}\n\n")
	}

	// Generate output interface
	if proc.Output != nil && proc.Output.Schema != nil {
		outputName := g.toPascalCase(name) + "Output"
		output.WriteString(fmt.Sprintf("export interface %s {\n", outputName))
		if err := g.generateObjectProperties(output, proc.Output.Schema, "  "); err != nil {
			return err
		}
		output.WriteString("}\n\n")
	}

	// Generate error types
	if len(proc.Errors) > 0 {
		g.generateErrorTypes(output, name, proc.Errors)
	}

	return nil
}

// generateSubscriptionType generates TypeScript types for a subscription
func (g *TypeScriptGenerator) generateSubscriptionType(output *strings.Builder, name string, sub SubscriptionDefinition) error {
	if sub.Description != "" {
		output.WriteString(fmt.Sprintf("/**\n * %s\n */\n", sub.Description))
	}

	// Generate parameters interface
	if sub.Parameters != nil {
		paramsName := g.toPascalCase(name) + "Params"
		output.WriteString(fmt.Sprintf("export interface %s {\n", paramsName))
		if err := g.generateObjectProperties(output, sub.Parameters, "  "); err != nil {
			return err
		}
		output.WriteString("}\n\n")
	}

	// Generate message types
	if sub.Message != nil && sub.Message.Schema != nil {
		messageName := g.toPascalCase(name) + "Message"
		output.WriteString(fmt.Sprintf("export interface %s {\n", messageName))
		if err := g.generateObjectProperties(output, sub.Message.Schema, "  "); err != nil {
			return err
		}
		output.WriteString("}\n\n")
	}

	// Generate error types
	if len(sub.Errors) > 0 {
		g.generateErrorTypes(output, name, sub.Errors)
	}

	return nil
}

// generateSchemaFieldType generates TypeScript for a schema field definition
func (g *TypeScriptGenerator) generateSchemaFieldType(output *strings.Builder, name string, schema SchemaField) error {
	if schema.Description != "" {
		output.WriteString(fmt.Sprintf("/**\n * %s\n */\n", schema.Description))
	}

	typeName := g.toPascalCase(name)

	// Handle different schema types
	switch schema.Type {
	case "object":
		output.WriteString(fmt.Sprintf("export interface %s {\n", typeName))
		if err := g.generateObjectProperties(output, schema, "  "); err != nil {
			return err
		}
		output.WriteString("}\n")
	case "array":
		output.WriteString(fmt.Sprintf("export type %s = %s[];\n", typeName, g.getTypeScriptType(schema.Items)))
	case "string":
		if len(schema.Enum) > 0 {
			enumValues := make([]string, len(schema.Enum))
			for i, val := range schema.Enum {
				enumValues[i] = fmt.Sprintf("'%s'", val)
			}
			output.WriteString(fmt.Sprintf("export type %s = %s;\n", typeName, strings.Join(enumValues, " | ")))
		} else if len(schema.KnownValues) > 0 {
			enumValues := make([]string, len(schema.KnownValues))
			for i, val := range schema.KnownValues {
				enumValues[i] = fmt.Sprintf("'%s'", val)
			}
			output.WriteString(fmt.Sprintf("export type %s = %s;\n", typeName, strings.Join(enumValues, " | ")))
		} else {
			output.WriteString(fmt.Sprintf("export type %s = string;\n", typeName))
		}
	case "integer":
		output.WriteString(fmt.Sprintf("export type %s = number;\n", typeName))
	case "boolean":
		output.WriteString(fmt.Sprintf("export type %s = boolean;\n", typeName))
	case "null":
		output.WriteString(fmt.Sprintf("export type %s = null;\n", typeName))
	default:
		output.WriteString(fmt.Sprintf("export type %s = any;\n", typeName))
	}

	return nil
}

// generateObjectProperties generates properties for an object schema
func (g *TypeScriptGenerator) generateObjectProperties(output *strings.Builder, schema interface{}, indent string) error {
	// Convert to map to access properties
	schemaMap, ok := schema.(map[string]interface{})
	if !ok {
		// Try to convert SchemaField
		if schemaField, ok := schema.(SchemaField); ok {
			schemaMap = make(map[string]interface{})
			if schemaField.Properties != nil {
				for k, v := range schemaField.Properties {
					schemaMap[k] = v
				}
			}
		} else {
			return fmt.Errorf("unsupported schema type for object properties: %T", schema)
		}
	}

	properties, ok := schemaMap["properties"].(map[string]interface{})
	if !ok {
		// No properties defined
		return nil
	}

	required := make(map[string]bool)
	if requiredSlice, ok := schemaMap["required"].([]interface{}); ok {
		for _, req := range requiredSlice {
			if reqStr, ok := req.(string); ok {
				required[reqStr] = true
			}
		}
	}

	for propName, propDef := range properties {
		// Add property comment if it has a description
		if propMap, ok := propDef.(map[string]interface{}); ok {
			if desc, ok := propMap["description"].(string); ok && desc != "" {
				output.WriteString(fmt.Sprintf("%s/**\n%s * %s\n%s */\n", indent, indent, desc, indent))
			}
		}

		// Determine if property is optional
		isRequired := required[propName]
		optional := ""
		if !isRequired {
			optional = "?"
		}

		// Generate property type
		propType := g.getTypeScriptType(propDef)
		output.WriteString(fmt.Sprintf("%s%s%s: %s;\n", indent, propName, optional, propType))
	}

	return nil
}

// getTypeScriptType converts a schema definition to a TypeScript type string
func (g *TypeScriptGenerator) getTypeScriptType(schema interface{}) string {
	if schema == nil {
		return "any"
	}

	schemaMap, ok := schema.(map[string]interface{})
	if !ok {
		return "any"
	}

	schemaType, ok := schemaMap["type"].(string)
	if !ok {
		// Check for $ref
		if ref, ok := schemaMap["$ref"].(string); ok {
			return g.toPascalCase(strings.TrimPrefix(ref, "#"))
		}
		// Check for ref (atproto style)
		if ref, ok := schemaMap["ref"].(string); ok {
			// Extract the type name after the # symbol
			parts := strings.Split(ref, "#")
			if len(parts) > 1 {
				return g.toPascalCase(parts[len(parts)-1])
			}
			return g.toPascalCase(ref)
		}
		return "any"
	}

	switch schemaType {
	case "string":
		if enum, ok := schemaMap["enum"].([]interface{}); ok && len(enum) > 0 {
			enumValues := make([]string, len(enum))
			for i, val := range enum {
				enumValues[i] = fmt.Sprintf("'%s'", val)
			}
			return strings.Join(enumValues, " | ")
		}
		if knownValues, ok := schemaMap["knownValues"].([]interface{}); ok && len(knownValues) > 0 {
			enumValues := make([]string, len(knownValues))
			for i, val := range knownValues {
				enumValues[i] = fmt.Sprintf("'%s'", val)
			}
			return strings.Join(enumValues, " | ")
		}
		return "string"
	case "integer", "number":
		return "number"
	case "boolean":
		return "boolean"
	case "null":
		return "null"
	case "array":
		if items, ok := schemaMap["items"]; ok {
			itemType := g.getTypeScriptType(items)
			return itemType + "[]"
		}
		return "any[]"
	case "object":
		return "Record<string, any>"
	case "ref":
		if ref, ok := schemaMap["$ref"].(string); ok {
			return g.toPascalCase(strings.TrimPrefix(ref, "#"))
		}
		if ref, ok := schemaMap["ref"].(string); ok {
			// Extract the type name after the # symbol
			parts := strings.Split(ref, "#")
			if len(parts) > 1 {
				return g.toPascalCase(parts[len(parts)-1])
			}
			return g.toPascalCase(ref)
		}
		return "any"
	default:
		return "any"
	}
}

// generateErrorTypes generates TypeScript types for errors
func (g *TypeScriptGenerator) generateErrorTypes(output *strings.Builder, name string, errors []ErrorDef) {
	errorName := g.toPascalCase(name) + "Error"
	output.WriteString(fmt.Sprintf("export type %s = \n", errorName))

	for i, err := range errors {
		separator := " |"
		if i == len(errors)-1 {
			separator = ";"
		}
		output.WriteString(fmt.Sprintf("  '%s'%s\n", err.Name, separator))
	}
	output.WriteString("\n")
}

// toPascalCase converts a string to PascalCase
func (g *TypeScriptGenerator) toPascalCase(s string) string {
	if s == "" {
		return ""
	}

	// Handle special cases
	if s == "main" {
		return "Main"
	}

	// First, split on common delimiters
	parts := strings.FieldsFunc(s, func(r rune) bool {
		return r == '_' || r == '-' || r == '.' || r == '/'
	})

	var result strings.Builder
	for _, part := range parts {
		if part != "" {
			// Handle camelCase by detecting uppercase letters
			var words []string
			var current strings.Builder

			for i, r := range part {
				if i > 0 && r >= 'A' && r <= 'Z' {
					// Found uppercase letter, start new word
					if current.Len() > 0 {
						words = append(words, current.String())
						current.Reset()
					}
				}
				current.WriteRune(r)
			}
			if current.Len() > 0 {
				words = append(words, current.String())
			}

			// If no camelCase detected, treat as single word
			if len(words) == 0 {
				words = []string{part}
			}

			// Capitalize each word
			for _, word := range words {
				if word != "" {
					result.WriteString(strings.ToUpper(word[:1]) + strings.ToLower(word[1:]))
				}
			}
		}
	}

	return result.String()
}

// getLastSectionOfID extracts the last section from a lexicon ID
func (g *TypeScriptGenerator) getLastSectionOfID(id string) string {
	parts := strings.Split(id, ".")
	if len(parts) > 0 {
		return parts[len(parts)-1]
	}
	return "main"
}
